#!/usr/bin/env ruby
input = ARGF.each_line.map { |line| line.strip.split('x', 3).map(&:to_i) }
l, w, h = input.reduce([[], [], []]) do |memo, element|
  memo.tap { (0..2).each { |i| memo[i] << element[i] } }
end

output_stride = true
# When loading this data, we'll use VMOVDQA, so data must be aligned to a 32-byte boundary.
puts '.align 32'
puts '.Linput:'
[l, w, h].each do |array|
  puts ".int #{array.join(', ')}"
  # Zero-pad the array to a 32-byte boundary. Due to the nature of the algorithm, these zero values
  # will not have any effect on the result, which yields the nice property that we won't have to
  # special-case handling of an "odd" number of final values that won't fill the SIMD register.
  puts '.align 32'
  if output_stride
    # For the first array, output the number of bytes that a single array spans as a compile-time
    # constant.
    puts '.set stride, . - .Linput'
    output_stride = false
  end
end
